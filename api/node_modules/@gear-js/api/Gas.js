import { isString, isHex } from '@polkadot/util';
import '@polkadot/util-crypto';
import '@polkadot/types';
import './utils/prefixes.js';
import './utils/separator.js';
import '@polkadot/api';
import './create-type/interfaces.js';
import { createPayload } from './create-type/create-payload.js';

class GearGas {
    _api;
    constructor(_api) {
        this._api = _api;
    }
    #getTypeAndMeta(metaOrTypeOfPayload, metaType) {
        if (!metaOrTypeOfPayload) {
            return [undefined, undefined];
        }
        if (isString(metaOrTypeOfPayload)) {
            return [metaOrTypeOfPayload, undefined];
        }
        else {
            return [metaOrTypeOfPayload[metaType], metaOrTypeOfPayload];
        }
    }
    async initUpload(sourceId, code, payload, value, allowOtherPanics, metaOrTypeOfPayload) {
        const [type, meta] = this.#getTypeAndMeta(metaOrTypeOfPayload, 'init_input');
        return this._api.rpc['gear'].calculateInitUploadGas(sourceId, isHex(code) ? code : this._api.createType('Bytes', Array.from(code)).toHex(), createPayload(payload, type, meta?.types), value || 0, allowOtherPanics || true);
    }
    async initCreate(sourceId, codeId, payload, value, allowOtherPanics, metaOrTypeOfPayload) {
        const [type, meta] = this.#getTypeAndMeta(metaOrTypeOfPayload, 'init_input');
        return this._api.rpc['gear'].calculateInitCreateGas(sourceId, codeId, createPayload(payload, type, meta?.types), value || 0, allowOtherPanics || true);
    }
    async handle(sourceId, destinationId, payload, value, allowOtherPanics, metaOrTypeOfPayload) {
        const [type, meta] = this.#getTypeAndMeta(metaOrTypeOfPayload, 'handle_input');
        return this._api.rpc['gear'].calculateHandleGas(sourceId, destinationId, createPayload(payload, type, meta?.types), value || 0, allowOtherPanics || true);
    }
    async reply(sourceId, messageId, exitCode, payload, value, allowOtherPanics, metaOrTypeOfPayload) {
        const [type, meta] = this.#getTypeAndMeta(metaOrTypeOfPayload, 'handle_input');
        return this._api.rpc['gear'].calculateReplyGas(sourceId, messageId, exitCode, createPayload(payload, type, meta?.types), value || 0, allowOtherPanics || true);
    }
}

export { GearGas };
