'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('@polkadot/util');
var generate = require('./utils/generate.js');
require('./utils/prefixes.js');
require('./utils/separator.js');
var validate = require('./utils/validate.js');
require('@polkadot/api');
require('@polkadot/util-crypto');
var Transaction = require('./Transaction.js');

class GearCode extends Transaction.GearTransaction {
    /**
     * ### Submit code without initialization
     * @param code
     * @returns Code hash
     */
    async upload(code) {
        const codeHash = generate.generateCodeHash(code);
        await validate.validateCodeId(codeHash, this._api);
        const codeBytes = this._api.createType('Bytes', Array.from(code));
        this.extrinsic = this._api.tx.gear.uploadCode(codeBytes);
        return { codeHash, submitted: this.extrinsic };
    }
    /**
     * ### Check that codeId exists on chain
     * @param codeId
     */
    async exists(codeId) {
        const codeMetadata = (await this._api.query.gearProgram.metadataStorage(codeId));
        return codeMetadata.isSome;
    }
    /**
     * ### Get code storage
     * @param codeId
     */
    async storage(codeId) {
        return this._api.query.gearProgram.codeStorage(codeId);
    }
    /**
     * ### Get static pages of code
     * @param codeId
     */
    async staticPages(codeId) {
        const storage = await this.storage(codeId);
        return storage.isSome ? storage.unwrap().staticPages.toNumber() : null;
    }
    /**
     * ### Get all ids of codes uploaded on connected chain
     * @returns array of code ids uploaded on chain
     */
    async all() {
        const keyPrefix = this._api.query.gearProgram.metadataStorage.keyPrefix();
        const codeMetadata = await this._api.rpc.state.getKeys(keyPrefix);
        const codeIds = codeMetadata.map((key) => '0x' + key.toHex().slice(keyPrefix.length));
        return codeIds;
    }
}

exports.GearCode = GearCode;
