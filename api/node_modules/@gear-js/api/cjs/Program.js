'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utilCrypto = require('@polkadot/util-crypto');
var util = require('@polkadot/util');
var generate = require('./utils/generate.js');
var prefixes = require('./utils/prefixes.js');
require('./utils/separator.js');
var validate = require('./utils/validate.js');
require('@polkadot/api');
var Transaction = require('./Transaction.js');
require('./create-type/interfaces.js');
require('@polkadot/types');
var createPayload = require('./create-type/create-payload.js');
var program_errors = require('./errors/program.errors.js');
var Gas = require('./Gas.js');

class GearProgram extends Transaction.GearTransaction {
    _api;
    calculateGas;
    constructor(_api) {
        super(_api);
        this._api = _api;
        this.calculateGas = new Gas.GearGas(_api);
    }
    /** ### Upload program with code
     * @param program
     * @param meta Metadata
     * @returns ProgramId
     * @example
     * ```javascript
     * const code = fs.readFileSync('path/to/program.opt.wasm');
     * const meta = await getWasmMetadata(fs.readFileSync('path/to/program.meta.wasm'));
     * const api = await GearApi.create();
     * const { programId, codeId, salt, extrinsic } = api.program.upload({
     *   code,
     *   initPayload: {field: 'someValue'},
     *   gasLimit: 20_000_000,
     * }, meta)
     * api.program.signAndSend(account, (events) => {
     *   events.forEach(({event}) => console.log(event.toHuman()))
     * })
     * ```
     */
    upload(program, meta, messageType) {
        validate.validateValue(program.value, this._api);
        validate.validateGasLimit(program.gasLimit, this._api);
        const salt = program.salt || utilCrypto.randomAsHex(20);
        const code = this._api.createType('Bytes', Array.from(program.code));
        const payload = createPayload.createPayload(program.initPayload, messageType || meta?.init_input, meta?.types);
        const codeId = generate.generateCodeHash(code);
        const programId = generate.generateProgramId(code, salt);
        try {
            this.extrinsic = this._api.tx.gear.uploadProgram(code, salt, payload, program.gasLimit, program.value || 0);
            return { programId, codeId, salt, extrinsic: this.extrinsic };
        }
        catch (error) {
            throw new program_errors.SubmitProgramError();
        }
    }
    /** ## Create program using existed codeId
     * @param program
     * @param meta Metadata
     * @returns ProgramId
     * @example
     * ```javascript
     * const codeId = '0x...';
     * const meta = await getWasmMetadata(fs.readFileSync('path/to/program.meta.wasm'));
     * const api = await GearApi.create();
     * const { programId, salt, extrinsic } = api.program.create({
     *   codeId,
     *   initPayload: { field: 'someValue' },
     *   gasLimit: 20_000_000,
     * }, meta)
     * extrinsic.signAndSend(account, (events) => {
     *   events.forEach(({event}) => console.log(event.toHuman()))
     * })
     * ```
     */
    create(program, meta, messageType) {
        validate.validateValue(program.value, this._api);
        validate.validateGasLimit(program.gasLimit, this._api);
        const salt = program.salt || utilCrypto.randomAsHex(20);
        const payload = createPayload.createPayload(program.initPayload, messageType || meta?.init_input, meta?.types);
        const programId = generate.generateProgramId(program.codeId, salt);
        try {
            this.extrinsic = this._api.tx.gear.createProgram(program.codeId, salt, payload, program.gasLimit, program.value || 0);
            return { programId, salt, extrinsic: this.extrinsic };
        }
        catch (error) {
            throw new program_errors.SubmitProgramError();
        }
    }
    /**
     * Get ids of all uploaded programs
     * @returns
     */
    async allUploadedPrograms() {
        const keys = await this._api.rpc.state.getKeys(prefixes.GPROG);
        return keys.map((prog) => {
            return `0x${prog.toHex().slice(prefixes.GPROG_HEX.length + 2)}`;
        });
    }
    /**
     *
     * @param id some address in hex format
     * @returns if address belongs to program, method returns `true`, otherwise `false`
     */
    async exists(id) {
        const progs = await this._api.rpc.state.getKeys(prefixes.GPROG);
        const program = progs.find((prog) => prog.eq(`0x${prefixes.GPROG_HEX}${id.slice(2)}`));
        return Boolean(program);
    }
    /**
     * Get codeHash of program on-chain
     * @param programId
     * @returns codeHash in hex format
     */
    async codeHash(programId) {
        const program = await this._api.storage.gProg(programId);
        return util.u8aToHex(program.code_hash);
    }
}

exports.GearProgram = GearProgram;
