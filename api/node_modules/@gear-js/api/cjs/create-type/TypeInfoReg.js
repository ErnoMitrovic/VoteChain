'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var types = require('@polkadot/types');
var util = require('@polkadot/util');
var json = require('../utils/json.js');
var types$1 = require('../utils/types.js');
var regexp = require('../utils/regexp.js');

function getName(path, name, slice = -1) {
    if (name.endsWith(types$1.joinTypePath(path.slice(slice)))) {
        return name.slice(-types$1.joinTypePath(path.slice(slice)).length);
    }
    else {
        for (const i of path.slice(0, slice)) {
            name = name.slice(types$1.joinTypePath([i]).length);
        }
        return name;
    }
}
function replaceTypeNames(type, replaceMap) {
    for (const [oldName, newName] of replaceMap) {
        const regex = new RegExp(`\\b${oldName}\\b`, 'g');
        if (regex.test(type)) {
            type = type.replaceAll(regex, newName);
        }
    }
    return type;
}
class TypeInfoRegistry {
    registryTypes;
    #finalTypeDefinition;
    registry;
    #replaceMap;
    #typesDefinition;
    #portableReg;
    #restrictedNames;
    constructor(registryTypes) {
        this.registryTypes = util.isHex(registryTypes) ? util.hexToU8a(registryTypes) : registryTypes;
        this.registry = new types.TypeRegistry();
        this.#portableReg = new types.PortableRegistry(this.registry, this.registryTypes, true);
        this.#replaceMap = new Map();
        this.#typesDefinition = new Map();
        this.#restrictedNames = [];
        this.#finalTypeDefinition = undefined;
        this.#createAndRegisterTypes();
    }
    #prepareTypes() {
        for (const { id, type } of this.#portableReg.types) {
            const path = type.path.toHuman();
            const typeDef = this.#portableReg.getTypeDef(id);
            const regName = this.#portableReg.getName(id);
            if (regName) {
                let name = types$1.joinTypePath(path);
                if (name.length !== regName.length) {
                    name = name + regName.slice(name.length);
                }
                let slicedName = getName(path, name);
                if (this.#typesDefinition.has(slicedName)) {
                    this.#restrictedNames.push(slicedName);
                    this.#typesDefinition.get(slicedName).changeName = true;
                    slicedName = this.#getSlicedName(path, name, slicedName);
                }
                this.#typesDefinition.set(slicedName, { changeName: false, type: typeDef.type, fullName: regName, path });
            }
        }
        for (const [key, value] of this.#typesDefinition) {
            if (value.changeName) {
                const slicedName = this.#getSlicedName(value.path, value.fullName);
                this.#typesDefinition.set(slicedName, { ...value, changeName: false });
                this.#typesDefinition.delete(key);
            }
        }
    }
    #getSlicedName(path, fullName, name) {
        let slicedName = name ? name : getName(path, fullName);
        let slice = -2;
        while (this.#restrictedNames.includes(slicedName)) {
            slicedName = getName(path, fullName, slice);
            slice--;
        }
        return slicedName;
    }
    #createReplaceMap() {
        this.#typesDefinition.forEach((value, key) => {
            if (value.fullName !== key) {
                this.#replaceMap.set(value.fullName, key);
            }
        });
    }
    #createFinalTypeDefinition() {
        this.#finalTypeDefinition = {};
        this.#typesDefinition.forEach((value, key) => {
            const replacedTypeName = replaceTypeNames(value.type, this.#replaceMap);
            if (key !== replacedTypeName) {
                this.#finalTypeDefinition[key] = json.isJSON(replacedTypeName) ? json.toJSON(replacedTypeName) : replacedTypeName;
            }
        });
    }
    #registerTypes() {
        this.registry.setKnownTypes({ types: this.#finalTypeDefinition });
        this.registry.register(this.#finalTypeDefinition);
    }
    #createAndRegisterTypes() {
        this.#prepareTypes();
        this.#createReplaceMap();
        this.#createFinalTypeDefinition();
        this.#registerTypes();
    }
    getShortName(fullName) {
        if (fullName.includes('::')) {
            fullName = types$1.joinTypePath(fullName.split('::'));
        }
        if (fullName.includes('_')) {
            fullName = types$1.joinTypePath(fullName.split('_'));
        }
        if (!this.#replaceMap.has(fullName)) {
            return fullName;
        }
        return this.#replaceMap.get(fullName);
    }
    getTypes() {
        return this.#finalTypeDefinition;
    }
    createType(typeName, data) {
        return this.registry.createType(typeName, data);
    }
    getGenericName(type) {
        const matches = type.match(regexp.REGULAR_EXP.endWord);
        const typeName = this.getShortName(matches[0]);
        for (const match of matches.slice(1)) {
            if (`${typeName}${match}` in this.#finalTypeDefinition) {
                return `${typeName}${match}${type.slice(typeName.length)}`;
            }
        }
        return type;
    }
}

exports.TypeInfoRegistry = TypeInfoRegistry;
