'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var util = require('@polkadot/util');
var types = require('@polkadot/types');
var types$1 = require('../utils/types.js');
var TypeInfoReg = require('./TypeInfoReg.js');
var json = require('../utils/json.js');

class CreateType {
    registry;
    constructor(registryOrRegistryTypes) {
        if (!registryOrRegistryTypes) {
            this.registry = new types.TypeRegistry();
        }
        else if (util.isHex(registryOrRegistryTypes) || util.isU8a(registryOrRegistryTypes)) {
            const typeInfoReg = new TypeInfoReg.TypeInfoRegistry(registryOrRegistryTypes);
            this.registry = typeInfoReg.registry;
        }
        else if (registryOrRegistryTypes) {
            this.registry = registryOrRegistryTypes;
        }
    }
    /**
     * Register custom types in case of use custom types without
     * @param types
     * @example
     * ```javascript
     * const types = {
     *    CustomStruct: {
     *      fieldA: 'String',
     *      fieldB: 'u8'
     *    },
     *    CustomEnum: {
     *      _enum: {
     *        optionA: 'Option<CustomStruct>',
     *        optionB: 'BTreeSet<i32>'
     *      }
     *    }
     * };
     * const createType = new CreateType();
     * createType.registerTypes(types);
     * createType.create('CustomStruct', { fieldA: 'Hello', fieldB: 255 });
     * ```
     */
    registerTypes(types) {
        this.registry.setKnownTypes({ types: { ...types } });
        this.registry.register({ ...types });
    }
    create(type, payload, registryTypesOrMetadata) {
        [type, payload] = types$1.getTypeAndPayload(type, payload);
        if (registryTypesOrMetadata) {
            const registryTypes = util.isHex(registryTypesOrMetadata) || util.isU8a(registryTypesOrMetadata)
                ? registryTypesOrMetadata
                : registryTypesOrMetadata.types;
            const typeInfoReg = new TypeInfoReg.TypeInfoRegistry(registryTypes);
            this.registry = typeInfoReg.registry;
            type = types$1.typeIsGeneric(type) ? typeInfoReg.getGenericName(type) : typeInfoReg.getShortName(type);
        }
        return this.createType(type, json.isJSON(payload) ? json.toJSON(payload) : payload);
    }
    /**
     *
     * @param type `TypeName` to encode or decode payload
     * @param payload `Payload` that have to be encoded or decoded
     * @param registryTypesOrMetadata
     * @returns Codec
     * @example
     * ```javascript
     * const encoded = CreateType.create('String', 'Hello, World');
     * console.log(encoded.toHex()); // 0x48656c6c6f2c20576f726c6421
     * ```
     */
    static create(type, payload, registryTypesOrMetadata) {
        const createType = new CreateType();
        return createType.create(type, payload, registryTypesOrMetadata);
    }
    createType(type, data) {
        if (types$1.typeIsString(type)) {
            return this.registry.createType('String', data);
        }
        else if (type.toLowerCase() === 'bytes') {
            if (data instanceof Uint8Array) {
                return this.registry.createType('Bytes', Array.from(data));
            }
            else if (data instanceof types.Bytes) {
                return data;
            }
            return this.registry.createType('Bytes', data);
        }
        else {
            return this.registry.createType(type, data);
        }
    }
}

exports.CreateType = CreateType;
