'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var util = require('@polkadot/util');
var types = require('@polkadot/types');
var validation_errors = require('../errors/validation.errors.js');

function validateValue(value, api) {
    if (!value)
        return;
    const existentialDeposit = api.existentialDeposit;
    const bigintValue = value instanceof Uint8Array
        ? util.u8aToBigInt(value)
        : value instanceof types.u128 || value instanceof util.BN
            ? BigInt(value.toString())
            : BigInt(value);
    if (bigintValue > 0 && bigintValue < existentialDeposit.toBigInt()) {
        throw new validation_errors.ValidationError(`Value less than minimal. Minimal value: ${existentialDeposit.toHuman()}`);
    }
}
function validateGasLimit(gas, api) {
    if (gas === undefined)
        throw new validation_errors.ValidationError("Gas limit doesn't specified");
    const bigintGas = gas instanceof Uint8Array
        ? util.u8aToBigInt(gas)
        : gas instanceof types.u64 || gas instanceof util.BN
            ? BigInt(gas.toString())
            : BigInt(gas);
    if (bigintGas > api.blockGasLimit.toBigInt()) {
        throw new validation_errors.ValidationError(`GasLimit too high. Maximum gasLimit value is ${api.blockGasLimit.toHuman()}`);
    }
}
async function validateCodeId(codeId, api) {
    if (await api.code.exists(codeId)) {
        throw new validation_errors.ValidationError('Code already exists');
    }
}

exports.validateCodeId = validateCodeId;
exports.validateGasLimit = validateGasLimit;
exports.validateValue = validateValue;
