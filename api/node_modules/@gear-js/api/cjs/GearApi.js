'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var api = require('@polkadot/api');
var index = require('./default/index.js');
var State = require('./State.js');
var Waitlist = require('./Waitlist.js');
var Claim = require('./Claim.js');
var Program = require('./Program.js');
var Storage = require('./Storage.js');
var Mailbox = require('./Mailbox.js');
var Message = require('./Message.js');
var Balance = require('./Balance.js');
require('@polkadot/types');
var Events = require('./events/Events.js');
var Blocks = require('./Blocks.js');
var Code = require('./Code.js');

class GearApi extends api.ApiPromise {
    program;
    programState;
    message;
    balance;
    gearEvents;
    defaultTypes;
    blocks;
    storage;
    mailbox;
    claimValueFromMailbox;
    code;
    waitlist;
    constructor(options = {}) {
        const { types, providerAddress, ...restOptions } = options;
        const provider = restOptions?.provider || new api.WsProvider(providerAddress ?? 'ws://127.0.0.1:9944');
        const defaultTypes = types ? { ...types, ...index.gearTypes } : index.gearTypes;
        super({
            provider,
            derives: {},
            types: {
                ...defaultTypes,
            },
            rpc: {
                ...index.gearRpc,
            },
            // it's temporarily necessary to avoid the warning "API/INIT: Not decorating unknown runtime apis: GearApi/1"
            runtime: {
                GearApi: [
                    {
                        methods: {},
                        version: 1,
                    },
                ],
            },
            ...restOptions,
        });
        this.isReady.then(() => {
            this.program = new Program.GearProgram(this);
            this.message = new Message.GearMessage(this);
            this.balance = new Balance.GearBalance(this);
            this.gearEvents = new Events.GearEvents(this);
            this.defaultTypes = defaultTypes;
            this.programState = new State.GearProgramState(this);
            this.blocks = new Blocks.GearBlock(this);
            this.storage = new Storage.GearStorage(this);
            this.claimValueFromMailbox = new Claim.GearClaimValue(this);
            this.mailbox = new Mailbox.GearMailbox(this);
            this.code = new Code.GearCode(this);
            this.waitlist = new Waitlist.GearWaitlist(this);
        });
    }
    static async create(options) {
        const api = new GearApi(options);
        await api.isReady;
        return api;
    }
    async totalIssuance() {
        return (await this.query.balances.totalIssuance()).toHuman();
    }
    async chain() {
        return (await this.rpc.system.chain()).toHuman();
    }
    async nodeName() {
        return (await this.rpc.system.name()).toHuman();
    }
    async nodeVersion() {
        return (await this.rpc.system.version()).toHuman();
    }
    get existentialDeposit() {
        return this.consts.balances.existentialDeposit;
    }
    get blockGasLimit() {
        return this.consts.gearGas.blockGasLimit;
    }
    get mailboxTreshold() {
        return this.consts.gear.mailboxThreshold;
    }
    get waitlistCost() {
        return this.consts.gearScheduler.waitlistCost;
    }
    /**
     * Method provides opportunity to get informations about error occurs in ExtrinsicFailed event
     * @param event
     * @returns
     */
    getExtrinsicFailedError(event) {
        const error = event.data[0];
        const { isModule, asModule } = error;
        return isModule ? this.registry.findMetaError(asModule) : null;
    }
}

exports.GearApi = GearApi;
