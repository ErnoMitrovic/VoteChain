'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('@polkadot/util');
require('@polkadot/util-crypto');
var CreateType = require('./create-type/CreateType.js');
require('./utils/prefixes.js');
require('./utils/separator.js');
require('@polkadot/types');
var state_errors = require('./errors/state.errors.js');
require('@polkadot/api');
require('./create-type/interfaces.js');
var WasmMeta = require('./wasm/WasmMeta.js');
var readState = require('./wasm/readState.js');
var Storage = require('./Storage.js');

class GearProgramState extends Storage.GearStorage {
    /**
     * Decode state to meta_state_output type
     * @param state - Uint8Array state representation
     * @param meta - Metadata
     * @returns decoded state
     */
    decodeState(state, meta) {
        if (!state) {
            throw new state_errors.ReadStateError('Unable to read state. meta_state function is not specified in metadata');
        }
        const bytes = this._api.createType('Bytes', Array.from(state));
        const decoded = CreateType.CreateType.create(meta.meta_state_output, bytes, meta.types);
        return decoded;
    }
    /**
     * Encode input parameters to read meta state
     * @param meta - Metadata
     * @param inputValue - input parameters
     * @returns ArrayBuffer with encoded data
     */
    encodeInput(meta, inputValue) {
        const encoded = CreateType.CreateType.create(meta.meta_state_input, inputValue, meta.types);
        return encoded.toU8a();
    }
    /**
     * Read state of particular program
     * @param programId
     * @param metaWasm - file with metadata
     * @returns decoded state
     */
    async read(programId, metaWasm, inputValue) {
        const codeHash = await this._api.program.codeHash(programId);
        let initialSize = await this._api.code.staticPages(codeHash);
        const program = await this.gProg(programId);
        program.allocations.forEach((value) => {
            if (value.gtn(initialSize - 1)) {
                initialSize = value.toNumber();
            }
        });
        initialSize++;
        const pages = await this.gPages(programId, program);
        const blockHash = await this._api.blocks.getFinalizedHead();
        const block = await this._api.blocks.get(blockHash);
        const blockTimestamp = await this._api.blocks.getBlockTimestamp(block);
        const blockNumber = block.block.header.number.unwrap();
        if (!pages) {
            throw new state_errors.ReadStateError('Unable to read state. Unable to recieve program pages from chain');
        }
        const metadata = await WasmMeta.getWasmMetadata(metaWasm);
        if (!metadata.meta_state_output) {
            throw new state_errors.ReadStateError('Unable to read state. meta_state_output type is not specified in metadata');
        }
        if (metadata.meta_state_input && inputValue === undefined) {
            throw new state_errors.ReadStateError('Unable to read state. inputValue not specified');
        }
        const encodedInput = inputValue === undefined ? undefined : this.encodeInput(metadata, inputValue);
        const state = await readState.readState(metaWasm, initialSize, pages, encodedInput, blockTimestamp.unwrap(), blockNumber);
        return this.decodeState(state, metadata);
    }
}

exports.GearProgramState = GearProgramState;
