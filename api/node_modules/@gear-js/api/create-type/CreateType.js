import { isHex, isU8a } from '@polkadot/util';
import { TypeRegistry, Bytes } from '@polkadot/types';
import { getTypeAndPayload, typeIsGeneric, typeIsString } from '../utils/types.js';
import { TypeInfoRegistry } from './TypeInfoReg.js';
import { isJSON, toJSON } from '../utils/json.js';

class CreateType {
    registry;
    constructor(registryOrRegistryTypes) {
        if (!registryOrRegistryTypes) {
            this.registry = new TypeRegistry();
        }
        else if (isHex(registryOrRegistryTypes) || isU8a(registryOrRegistryTypes)) {
            const typeInfoReg = new TypeInfoRegistry(registryOrRegistryTypes);
            this.registry = typeInfoReg.registry;
        }
        else if (registryOrRegistryTypes) {
            this.registry = registryOrRegistryTypes;
        }
    }
    /**
     * Register custom types in case of use custom types without
     * @param types
     * @example
     * ```javascript
     * const types = {
     *    CustomStruct: {
     *      fieldA: 'String',
     *      fieldB: 'u8'
     *    },
     *    CustomEnum: {
     *      _enum: {
     *        optionA: 'Option<CustomStruct>',
     *        optionB: 'BTreeSet<i32>'
     *      }
     *    }
     * };
     * const createType = new CreateType();
     * createType.registerTypes(types);
     * createType.create('CustomStruct', { fieldA: 'Hello', fieldB: 255 });
     * ```
     */
    registerTypes(types) {
        this.registry.setKnownTypes({ types: { ...types } });
        this.registry.register({ ...types });
    }
    create(type, payload, registryTypesOrMetadata) {
        [type, payload] = getTypeAndPayload(type, payload);
        if (registryTypesOrMetadata) {
            const registryTypes = isHex(registryTypesOrMetadata) || isU8a(registryTypesOrMetadata)
                ? registryTypesOrMetadata
                : registryTypesOrMetadata.types;
            const typeInfoReg = new TypeInfoRegistry(registryTypes);
            this.registry = typeInfoReg.registry;
            type = typeIsGeneric(type) ? typeInfoReg.getGenericName(type) : typeInfoReg.getShortName(type);
        }
        return this.createType(type, isJSON(payload) ? toJSON(payload) : payload);
    }
    /**
     *
     * @param type `TypeName` to encode or decode payload
     * @param payload `Payload` that have to be encoded or decoded
     * @param registryTypesOrMetadata
     * @returns Codec
     * @example
     * ```javascript
     * const encoded = CreateType.create('String', 'Hello, World');
     * console.log(encoded.toHex()); // 0x48656c6c6f2c20576f726c6421
     * ```
     */
    static create(type, payload, registryTypesOrMetadata) {
        const createType = new CreateType();
        return createType.create(type, payload, registryTypesOrMetadata);
    }
    createType(type, data) {
        if (typeIsString(type)) {
            return this.registry.createType('String', data);
        }
        else if (type.toLowerCase() === 'bytes') {
            if (data instanceof Uint8Array) {
                return this.registry.createType('Bytes', Array.from(data));
            }
            else if (data instanceof Bytes) {
                return data;
            }
            return this.registry.createType('Bytes', data);
        }
        else {
            return this.registry.createType(type, data);
        }
    }
}

export { CreateType };
